<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TensorFlow和Pytorch对应版本对照表</title>
    <link href="/2023/02/02/TensorFlow%E5%92%8CPytorch%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <url>/2023/02/02/TensorFlow%E5%92%8CPytorch%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E5%AF%B9%E7%85%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="TensorFlow和Pytorch对应版本对照表"><a href="#TensorFlow和Pytorch对应版本对照表" class="headerlink" title="TensorFlow和Pytorch对应版本对照表"></a>TensorFlow和Pytorch对应版本对照表</h2><p>备注：<a href="https://blog.csdn.net/DuLNode/article/details/123428294?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-123428294-blog-121866555.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-123428294-blog-121866555.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=2">原文链接</a></p><h3 id="TensorFlow和Pytorch对应版本对照表-1"><a href="#TensorFlow和Pytorch对应版本对照表-1" class="headerlink" title="TensorFlow和Pytorch对应版本对照表"></a>TensorFlow和Pytorch对应版本对照表</h3><ul><li><a href="#TensorFlow_2">TensorFlow对应版本对照表</a></li><li><a href="#Pytorch_29">Pytorch对应版本对照表</a></li></ul><h2 id="TensorFlow对应版本对照表"><a href="#TensorFlow对应版本对照表" class="headerlink" title="TensorFlow对应版本对照表"></a>TensorFlow对应版本对照表</h2><table><thead><tr><th>版本</th><th>Python 版本</th><th>编译器</th><th>构建工具</th><th>cuDNN</th><th>CUDA</th></tr></thead><tbody><tr><td>tensorflow_gpu-2.6.0</td><td>3.6-3.9</td><td>MSVC 2019</td><td>Bazel 3.7.2</td><td>8.1</td><td>11.2</td></tr><tr><td>tensorflow_gpu-2.5.0</td><td>3.6-3.9</td><td>MSVC 2019</td><td>Bazel 3.7.2</td><td>8.1</td><td>11.2</td></tr><tr><td>tensorflow_gpu-2.4.0</td><td>3.6-3.8</td><td>MSVC 2019</td><td>Bazel 3.1.0</td><td>8.0</td><td>11.0</td></tr><tr><td>tensorflow_gpu-2.3.0</td><td>3.5-3.8</td><td>MSVC 2019</td><td>Bazel 3.1.0</td><td>7.6</td><td>10.1</td></tr><tr><td>tensorflow_gpu-2.2.0</td><td>3.5-3.8</td><td>MSVC 2019</td><td>Bazel 2.0.0</td><td>7.6</td><td>10.1</td></tr><tr><td>tensorflow_gpu-2.1.0</td><td>3.5-3.7</td><td>MSVC 2019</td><td>Bazel 0.27.1-0.29.1</td><td>7.6</td><td>10.1</td></tr><tr><td>tensorflow_gpu-2.0.0</td><td>3.5-3.7</td><td>MSVC 2017</td><td>Bazel 0.26.1</td><td>7.4</td><td>10</td></tr><tr><td>tensorflow_gpu-1.15.0</td><td>3.5-3.7</td><td>MSVC 2017</td><td>Bazel 0.26.1</td><td>7.4</td><td>10</td></tr><tr><td>tensorflow_gpu-1.14.0</td><td>3.5-3.7</td><td>MSVC 2017</td><td>Bazel 0.24.1-0.25.2</td><td>7.4</td><td>10</td></tr><tr><td>tensorflow_gpu-1.13.0</td><td>3.5-3.7</td><td>MSVC 2015 update 3</td><td>Bazel 0.19.0-0.21.0</td><td>7.4</td><td>10</td></tr><tr><td>tensorflow_gpu-1.12.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Bazel 0.15.0</td><td>7.2</td><td>9.0</td></tr><tr><td>tensorflow_gpu-1.11.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Bazel 0.15.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.10.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.9.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.8.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.7.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.6.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.5.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.4.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>6</td><td>8</td></tr><tr><td>tensorflow_gpu-1.3.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>6</td><td>8</td></tr><tr><td>tensorflow_gpu-1.2.0</td><td>3.5-3.6</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>5.1</td><td>8</td></tr><tr><td>tensorflow_gpu-1.1.0</td><td>3.5</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>5.1</td><td>8</td></tr><tr><td>tensorflow_gpu-1.0.0</td><td>3.5</td><td>MSVC 2015 update 3</td><td>Cmake v3.6.3</td><td>5.1</td><td>8</td></tr></tbody></table><h2 id="Pytorch对应版本对照表"><a href="#Pytorch对应版本对照表" class="headerlink" title="Pytorch对应版本对照表"></a>Pytorch对应版本对照表</h2><p><a href="https://pytorch.org/get-started/previous-versions/">pytorch官网安装地址</a></p><table><thead><tr><th>PyTorch 版本</th><th>CUDA 环境</th></tr></thead><tbody><tr><td>0.4.1、1.2.0、1.4.0、1.5.0(1)、1.6.0、1.7.0(1)</td><td>9.2</td></tr><tr><td>1.2.0、1.1.0、1.0.0(1)</td><td>10.0</td></tr><tr><td>1.4.0、1.5.0(1)、1.6.0、1.7.0(1)</td><td>10.1</td></tr><tr><td>1.5.0(1)、1.6.0、1.7.0(1)、1.8.0(1)、1.9.0、1.10.0</td><td>10.2</td></tr><tr><td>1.7.0(1)</td><td>11.0</td></tr><tr><td>1.8.0(1)、1.9.0、1.10.0</td><td>11.1</td></tr><tr><td>1.8.0(1)、1.9.0、1.10.0</td><td>11.3</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00.Git 简介</title>
    <link href="/2023/02/01/00.Git%20%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/02/01/00.Git%20%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个分布式开放源码的版本控制软件。用于敏捷高效地处理任何或小或大的项目。同类型的其他版本控制工具有 CVS, Subversion（SVN）。<br>GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等</p><p>Git 完整命令手册地址：<a href="http://git-scm.com/docs">http://git-scm.com/docs</a></p><p>PDF 版命令手册：github-git-cheat-sheet.pdf</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04.Git 创建仓库</title>
    <link href="/2023/02/01/04.Git%20%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93/"/>
    <url>/2023/02/01/04.Git%20%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>使用一个已经存在的目录作为Git仓库或创建一个空目录</p><p>使用您当前目录作为Git仓库，我们只需使它初始化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br><br></code></pre></td></tr></table></figure><p>使用我们指定目录作为Git仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init newrepo<br><br></code></pre></td></tr></table></figure><p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add *.c<br>$ git add README<br>$ git commit -m <span class="hljs-string">&#x27;initial project version&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h2><p>克隆仓库的命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [url]<br></code></pre></td></tr></table></figure><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git://github.com/schacon/grit.git<br><br></code></pre></td></tr></table></figure><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git://github.com/schacon/grit.git mygrit<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.Git 常见问题</title>
    <link href="/2023/02/01/14.Git%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/02/01/14.Git%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Git-配置错误"><a href="#1-Git-配置错误" class="headerlink" title="1.Git 配置错误"></a>1.Git 配置错误</h2><p>仔细检查 本地 <strong>用户名称</strong>  <strong>邮箱账号</strong> 及是否使用 Github 中注册邮箱生成密钥，并在 Github 中添加。</p><h2 id="2-fatal-detected-dubious-ownership-in-repository-问题解决"><a href="#2-fatal-detected-dubious-ownership-in-repository-问题解决" class="headerlink" title="2.fatal: detected dubious ownership in repository 问题解决"></a>2.<a href="https://www.cnblogs.com/trygiser/p/16525410.html">fatal: detected dubious ownership in repository 问题解决</a></h2><p>问题的根源在于文件夹的所有权人和现在的用户不一致导致git提示。</p><p>临时解决办：，复制报错提示命令行，再次运行</p><p>永久解决办法：在文件夹的属性里面，更改所有者，并应用到所有的子目录和文件。</p><h2 id="3-博客推送相关命令"><a href="#3-博客推送相关命令" class="headerlink" title="3.博客推送相关命令"></a>3.博客推送相关命令</h2><p>1、切到项目目录中，例如 </p><pre><code class="hljs">E:\httpRunner_study</code></pre><p>2、初始化git仓库并在本地提交</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>初始化git仓库 <br>git init<br><br><span class="hljs-regexp">//</span>将当前目录下的文件添加到仓库（缓冲区）<br>git add .<br><br><span class="hljs-regexp">//</span>提交到本地仓库<br>git commit -m <span class="hljs-string">&quot;init project&quot;</span><br><br></code></pre></td></tr></table></figure><p>3、把本地仓库和远程关联，并推送到远程</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>与远程仓库关联<br>git remote add origin 远程仓库地址<br><br><span class="hljs-regexp">//</span>例如: 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名；<br>git remote add origin git@server-name:path/repo-name.git<br><span class="hljs-comment"># git remote add origin https://github.com/grayshiven/grayshiven.github.io.git</span><br><br><span class="hljs-regexp">//</span>推送到远程仓库<br>git push -u origin master<br><br></code></pre></td></tr></table></figure><p>执行以上操作就可以把本地新建的项目推送到 git 远程仓库了。</p><p>但在实际操作中，最后一步推送命令会报错，提示需要先  git pull 更新，而如果执行 git pull 或者 git pull origin master 都无法成功执行，会有其他的报错。</p><p>解决方案是，使用如下命令，强制推送到远程（可能会覆盖远程上已有分支、文件，使用前需要注意）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//强制推送到远程（可能会覆盖远程上已有的分支或文件）<br>git push -u origin <span class="hljs-keyword">master</span> <span class="hljs-title">-f</span><br><br></code></pre></td></tr></table></figure><p>注意：仅第一次需要这样执行，后续在推送代码时，git push 命令不需要再加上 -u 或者 -f 命令，使用正常推送命令就行了。</p><p>推送成功以后，就可以在本地项目中正常使用 git 命令进行更新、提交、推送等操作了。</p><p>推送失败，有可能是本地仓库与远程仓库，内容不一致</p><h2 id="3-error-failed-to-push-some-refs-to"><a href="#3-error-failed-to-push-some-refs-to" class="headerlink" title="3.error: failed to push some refs to"></a>3.error: failed to push some refs to</h2><h2 id="4-git提示error-setting-certificate-verify-locations错误解决"><a href="#4-git提示error-setting-certificate-verify-locations错误解决" class="headerlink" title="4.git提示error setting certificate verify locations错误解决"></a>4.git提示error setting certificate verify locations错误解决</h2><p>一般是因为没有找到ssl证书位置导致的</p><p>两种方法解决：</p><h3 id="1-重新配置证书的位置-windows证书一般在安装的git目录下的-mingw64-x2F-ssl-x2F-certs-x2F-ca-bundle-crt-目录-配置证书的位置"><a href="#1-重新配置证书的位置-windows证书一般在安装的git目录下的-mingw64-x2F-ssl-x2F-certs-x2F-ca-bundle-crt-目录-配置证书的位置" class="headerlink" title="1.  重新配置证书的位置 windows证书一般在安装的git目录下的  mingw64&#x2F;ssl&#x2F;certs&#x2F;ca-bundle.crt  目录 配置证书的位置"></a>1.  重新配置证书的位置 windows证书一般在安装的git目录下的  mingw64&#x2F;ssl&#x2F;certs&#x2F;ca-bundle.crt  目录 配置证书的位置</h3><p>git config –system http.sslcainfo  “<code>$gitPath/mingw64/ssl/certs/ca-bundle.crt&quot;  注：$</code>gitPath为git的安装目录</p><h3 id="2-关闭ssl认证"><a href="#2-关闭ssl认证" class="headerlink" title="2.  关闭ssl认证"></a>2.  关闭ssl认证</h3><p>git config –system http.sslcainfo  false</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.Git 服务器搭建</title>
    <link href="/2023/02/01/10.Git%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/02/01/10.Git%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>上一章节中我们远程仓库使用了 Github，Github 公开的项目是免费的，但是如果你不想让其他人看到你的项目就需要收费。</p><p>这时我们就需要自己搭建一台Git服务器作为私有仓库使用。</p><p>接下来我们将以 Centos 为例搭建 Git 服务器。</p><h3 id="1、安装Git"><a href="#1、安装Git" class="headerlink" title="1、安装Git"></a>1、安装Git</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> yum install <span class="hljs-built_in">curl</span><span class="hljs-literal">-devel</span> expat<span class="hljs-literal">-devel</span> gettext<span class="hljs-literal">-devel</span> openssl<span class="hljs-literal">-devel</span> zlib<span class="hljs-literal">-devel</span> perl<span class="hljs-literal">-devel</span><br><span class="hljs-variable">$</span> yum install git<br><br></code></pre></td></tr></table></figure><p>接下来我们 创建一个git用户组和用户，用来运行git服务：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>groupadd git<br><span class="hljs-variable">$ </span>adduser git -g git<br><br></code></pre></td></tr></table></figure><h3 id="2、创建证书登录"><a href="#2、创建证书登录" class="headerlink" title="2、创建证书登录"></a>2、创建证书登录</h3><p>收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件里，一行一个。</p><p>如果没有该文件创建它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /home/git/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> .ssh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 700 .ssh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> .ssh/authorized_keys</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 600 .ssh/authorized_keys</span><br><br></code></pre></td></tr></table></figure><h3 id="3、初始化Git仓库"><a href="#3、初始化Git仓库" class="headerlink" title="3、初始化Git仓库"></a>3、初始化Git仓库</h3><p>首先我们选定一个目录作为Git仓库，假定是&#x2F;home&#x2F;gitrepo&#x2F;w3cschoolcn.git，在&#x2F;home&#x2F;gitrepo目录下输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> /home</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> gitrepo</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> git:git gitrepo/</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> gitrepo</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init --bare w3cschoolcn.git</span><br>Initialized empty Git repository in /home/gitrepo/w3cschoolcn.git/<br><br></code></pre></td></tr></table></figure><p>以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chown</span> -R git:git w3cschoolcn.git</span><br><br></code></pre></td></tr></table></figure><h3 id="4、克隆仓库"><a href="#4、克隆仓库" class="headerlink" title="4、克隆仓库"></a>4、克隆仓库</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git clone git<span class="hljs-variable">@192</span>.<span class="hljs-number">168.45</span>.<span class="hljs-number">4</span><span class="hljs-symbol">:/home/gitrepo/w3cschoolcn</span>.git<br><span class="hljs-title class_">Cloning</span> into <span class="hljs-string">&#x27;w3cschoolcn&#x27;</span>...<br><span class="hljs-symbol">warning:</span> <span class="hljs-title class_">You</span> appear to have cloned an empty repository.<br><span class="hljs-title class_">Checking</span> connectivity... done.<br><br></code></pre></td></tr></table></figure><p>192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。</p><p>这样我们的 Git 服务器安装就完成了，接下来我们可以禁用 git 用户通过shell登录，可以通过编辑&#x2F;etc&#x2F;passwd文件完成。找到类似下面的一行：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">git:</span><span class="hljs-symbol">x:</span><span class="hljs-number">503</span><span class="hljs-symbol">:</span><span class="hljs-number">503</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:/home/git</span><span class="hljs-symbol">:/bin/bash</span><br><br></code></pre></td></tr></table></figure><p>改为：</p><pre><code class="hljs">git:x:503:503::/home/git:/sbin/nologin</code></pre>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.Git 常用命令速查表</title>
    <link href="/2023/02/01/11.Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <url>/2023/02/01/11.Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://atts.w3cschool.cn/attachments/image/20191225/1577243564858376.png" alt="git速查表下载app" title="git速查表下载app"></p><h2 id="创建-CREATE"><a href="#创建-CREATE" class="headerlink" title="创建 | CREATE"></a>创建 | CREATE</h2><hr><pre><code class="hljs">$ git clone ssh://user@domain.com/xx.git 克隆远程仓库$ git init 初始化本地 git 仓库（新建仓库）</code></pre><h2 id="本地更改-LOCAL-CHANGES"><a href="#本地更改-LOCAL-CHANGES" class="headerlink" title="本地更改 | LOCAL CHANGES"></a>本地更改 | LOCAL CHANGES</h2><hr><pre><code class="hljs">$ git status 查看当前版本状态（是否修改）$ git diff 显示所有未添加至 index 的变更$ git diff HEAD 查看已缓存的与未缓存的所有改动$ git add &lt;path&gt; 将该文件添加到缓存$ git commit -m ‘xxx’ 提交$ git commit --amend -m ‘xxx’ 合并上一次提交（用于反复修改）$ git commit -am ‘xxx’ 将 add 和 commit 合为一步</code></pre><h2 id="提交历史记录-COMMIT-HISTORY"><a href="#提交历史记录-COMMIT-HISTORY" class="headerlink" title="提交历史记录 | COMMIT HISTORY"></a>提交历史记录 | COMMIT HISTORY</h2><hr><pre><code class="hljs">$ git log 显示日志$ git show &lt;commit&gt; 显示某个提交的详细内容$ git blame &lt;file&gt; 在每一行显示 commit 号,提交者,最早提交日期</code></pre><h2 id="分支机构和标签-BRANCHES-amp-TAGS"><a href="#分支机构和标签-BRANCHES-amp-TAGS" class="headerlink" title="分支机构和标签 | BRANCHES &amp; TAGS"></a>分支机构和标签 | BRANCHES &amp; TAGS</h2><hr><pre><code class="hljs">$ git branch 显示本地分支$ git checkout &lt;branch&gt; 切换分支$ git branch &lt;new-branch&gt; 新建分支$ git branch --track &lt;new&gt; &lt;remote&gt; 创建新分支跟踪远程分支$ git branch -d &lt;branch&gt; 删除本地分支$ git tag &lt;tag-name&gt; 给当前分支打标签</code></pre><h2 id="更新和发布-UPDATE-amp-PUBLISH"><a href="#更新和发布-UPDATE-amp-PUBLISH" class="headerlink" title="更新和发布 | UPDATE &amp; PUBLISH"></a>更新和发布 | UPDATE &amp; PUBLISH</h2><hr><pre><code class="hljs">$ git remote -v 列出远程分支详细信息$ git remote show &lt;remote&gt; 显示某个分支信息$ git remote add &lt;remote&gt; &lt;url&gt; 添加一个新的远程仓库$ git fetch &lt;remote&gt; 获取远程分支，但不更新本地分支，另需 merge$ git pull &lt;remote&gt; &lt;branch&gt; 获取远程分支，并更新本地分支$ git push &lt;remote&gt; &lt;branch&gt; 推送本地更新到远程分支$ git push &lt;remote&gt; --delete &lt;branch&gt; 删除一个远程分支$ git push --tags 推送本地标签</code></pre><h2 id="合并与衍合-MERGE-amp-REBASE"><a href="#合并与衍合-MERGE-amp-REBASE" class="headerlink" title="合并与衍合 | MERGE &amp; REBASE"></a>合并与衍合 | MERGE &amp; REBASE</h2><hr><pre><code class="hljs">$ git merge &lt;branch&gt; 合并分支到当前分支，存在两个$ git rebase &lt;branch&gt; 合并分支到当前分支，存在一个$ git rebase --abort 回到执行 rebase 之前$ git rebase --continue 解决矛盾后继续执行 rebase$ git mergetool 使用 mergetool 解决冲突$ git add &lt;resolve-file&gt; 使用冲突文件解决冲突$ git rm &lt;resolved-file&gt;</code></pre><h2 id="撤消-UNDO"><a href="#撤消-UNDO" class="headerlink" title="撤消 | UNDO"></a>撤消 | UNDO</h2><hr><pre><code class="hljs">$ git reset --hard HEAD 将当前版本重置为 HEAD（用于 merge 失败）$ git reset --hard &lt;commit&gt; 将当前版本重置至某一个提交状态(慎用!)$ git reset &lt;commit&gt; 将当前版本重置至某一个提交状态，代码不变$ git reset --merge &lt;commit&gt; 重置至某一状态,保留版本库中不同的文件$ git reset --keep &lt;commit&gt; 重置至某一状态,重置变化的文件,代码改变$ git checkout HEAD &lt;file&gt; 丢弃本地更改信息并将其存入特定文件$ git revert &lt;commit&gt; 撤消提交</code></pre><h2 id="帮助-HELP帮助-HELP"><a href="#帮助-HELP帮助-HELP" class="headerlink" title="帮助 | HELP帮助 | HELP"></a>帮助 | HELP帮助 | HELP</h2><hr><pre><code class="hljs">$ git help &lt;command&gt;  获取命令行上的帮助</code></pre>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.Git 分支策略</title>
    <link href="/2023/02/01/12.Git%20%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/"/>
    <url>/2023/02/01/12.Git%20%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>本文将展示我一年前在自己的项目中成功运用的开发模型。我一直打算把这些东西写出来，但总是没有抽出时间，现在终于写好了。这里介绍的不是任何项目的细节，而是有关分支的策略以及对发布的管理。</p><p><img src="http://img.blog.csdn.net/20151229145702928"></p><p>在我的演示中，所有的操作都是通过 git 完成的。</p><h1 id="为什么选择-git-？"><a href="#为什么选择-git-？" class="headerlink" title="为什么选择 git ？"></a>为什么选择 git ？</h1><p>为了了断 git 和中心源代码控制系统的比较和争论，请移步这里看看 <a href="http://whygitisbetterthanx.com/">链接1</a> <a href="https://git.wiki.kernel.org/index.php/GitSvnComparsion">链接2</a>。作为一个开发者，我喜欢 git 超过其它任何现有的工具。Git 真正改变了开发者对于合并和分支的认识。在传统的 CVS&#x2F;SVN 里，合并&#x2F;分支总是有点令人害怕的(“注意合并冲突，它们会搞死你的”)。</p><p>但是 git 中的这些操作是如此的简单有效，它们真正作为你每天工作流程的一部分。比如，在 CVS&#x2F;SVN 的书籍里，分支和合并总是最后一个章节的讨论重点(对于高级用户)，而在每一本 git 的书里 <a href="http://book.git-scm.com/">链接1</a> <a href="http://pragprog.com/titles/tsgit/pragmatic-version-control-using-git">链接2</a>  <a href="http://github.com/progit/progit">链接3</a>，这些内容已经被包含在第三章(基础)里了。</p><p>因为它的简单直接和重复性，分支和合并不再令人害怕。版本控制工具比其它任何东西都支持分支&#x2F;合并。</p><p>有关工具就介绍到这里，我们现在进入开发模型这个正题。我要展现的模型本质上无外乎是一个流程的集合，每个团队成员都有必要遵守这些流程，来达到管理软件开发流程的目的。</p><h1 id="分散但也集中"><a href="#分散但也集中" class="headerlink" title="分散但也集中"></a>分散但也集中</h1><p>我们的分支模型中使用良好的代码库的设置方式，是围绕一个真实的中心代码库的。注意，这里的代码库仅仅被看做是一个中心代码库(因为 git 是 DVCS，即分散版本控制系统，从技术层面看，是没有所谓的中心代码库的)。我们习惯于把这个中心代码库命名为 origin，这同时也是所有 git 用户的习惯。</p><p><img src="http://img.blog.csdn.net/20151229150039013"></p><p>每一位开发者都向 origin 这个中心结点 pull 和 push。但是除此之外，每一位开发者也可以向其它结点 pull 改变形成子团队。比如，对于两个以上开发者同时开发一项大的新特性来说，为了不必过早向 origin 推送开发进度，这就非常有用。在上面的这个例子中，Alice 和 Bob、Alice 和 David、Clair 和 David 都是这样的子团队。</p><p>从技术角度，这无非意味着 Alice 定义一个名为 Bob 的 git remote，指向 Bob 的代码库，反之亦然。</p><h1 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h1><p><img src="http://img.blog.csdn.net/20151229150047888"></p><p>该开发模型的核心基本和现有的模型是一样的。中心代码库永远维持着两个主要的分支：</p><ul><li>master</li><li>develop</li></ul><p>在 origin 上的 master 分支和每个 git 用户的保持一致。而和 master 分支并行的另一个分支叫做 develop。</p><p>我们认为 origin&#x2F;master 是其 HEAD 源代码总是代表了生产环境准备就绪的状态的主分支。</p><p>我们认为 origin&#x2F;develop 是其 HEAD 源代码总是代表了最后一次交付的可以赶上下一次发布的状态的主分支。有人也把它叫做“集成分支”。该源代码还被作为了 nightly build 自动化任务的来源。</p><p>每当 develop 分支到达一个稳定的阶段，可以对外发布时，所有的改变都会被合并到master 分支，并打一个发布版本的 tag。具体操作方法我们稍后讨论。</p><p>因此，每次改动被合并到 master 的时候，这就是一个真正的新的发布产品。我们建议对此进行严格的控制，因此理论上我们可以为每次 master 分支的提交都挂一个钩子脚本，向生产环境自动化构建并发布我们的软件。</p><h1 id="支持型分支"><a href="#支持型分支" class="headerlink" title="支持型分支"></a>支持型分支</h1><p>我们的开发模型里，紧接着 master 和 develop 主分支的，是多种多样的支持型分支。它们的目的是帮助团队成员并行处理每次追踪特性、准备发布、快速修复线上问题等开发任务。和之前的主分支不同，这些分支的生命周期都是有限的，它们最终都会被删除掉。</p><p>我们可能会用到的不同类型的分支有：</p><ul><li>feature 分支</li><li>release 分支</li><li>hotfix 分支</li></ul><p>每一种分支都有一个特别的目的，并且有严格的规则，诸如哪些分支是它们的起始分支、哪些分支必须是它们合并的目标等。我们快速把它们过一遍。</p><p>这些“特殊”的分支在技术上是没有任何特殊的。分支的类型取决于我们如何运用它们。它们完完全全都是普通而又平凡的 git 分支。</p><h2 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h2><p><img src="http://img.blog.csdn.net/20151229150258259"></p><ul><li>可能派发自：develop</li><li>必须合并回：develop</li><li>分支命名规范：除了 master、develop、release-* 或 hotfix-* 的任何名字</li></ul><p>Feature 分支(有时也被称作 topic 分支)用来开发包括即将发布或远期发布的新的特性。当我们开始开发一个特性的时候，发布合并的目标可能还不太确定。Feature 分支的生命周期会和新特性的开发周期保持同步，但是最终会合并回 develop (恩，下次发布的时候把这个新特性带上)或被抛弃(真是一次杯具的尝试啊)。</p><p>Feature 分支通常仅存在于开发者的代码库中，并不出现在 origin 里。</p><h3 id="创建一个-feature-分支"><a href="#创建一个-feature-分支" class="headerlink" title="创建一个 feature 分支"></a>创建一个 feature 分支</h3><p>当开始一个新特性的时候，从 develop 分支派发出一个分支</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b myfeature develop<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&quot;myfeature&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="把完成的特性合并回-develop"><a href="#把完成的特性合并回-develop" class="headerlink" title="把完成的特性合并回 develop"></a>把完成的特性合并回 develop</h3><p>完成的特性可以合并回 develop 分支并赶上下一次发布：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git checkout develop<br>Switched to a new branch <span class="hljs-string">&quot;develop&quot;</span><br><span class="hljs-symbol">$</span> git merge --<span class="hljs-keyword">no</span>-ff myfeature<br><span class="hljs-function"><span class="hljs-title">Updating</span></span> ea1b82a.<span class="hljs-number">.05e9557</span><br>(Summary of changes)<br><span class="hljs-symbol">$</span> git branch -d myfeature<br>Deleted branch myfeature (was <span class="hljs-number">05e9557</span>)<br><span class="hljs-symbol">$</span> git push origin develop<br><br></code></pre></td></tr></table></figure><p>-no-ff 标记使得合并操作总是产生一次新的提交，哪怕合并操作可以快速完成。这个标记避免将 feature 分支和团队协作的所有提交的历史信息混在主分支的其它提交之后。比较一下：</p><p><img src="http://img.blog.csdn.net/20151229150332334"></p><p>在右边的例子里，我们不可能从 git 的历史记录中看出来哪些提交实现了这一特性——你可能不得不查看每一笔提交日志。恢复一个完整的特性(比如通过一组提交)在右边变成了一个头疼事情，而如果使用了 –no-ff 之后，就变得简单了。</p><p>是的，这会创造一些没有必要的(空的)提交记录，但是得到的是大量的好处。</p><p>不幸的是，我还没有找到一个在 git merge 时默认就把 –no-ff 标记打上的办法，但这很重要。</p><h2 id="release-分支"><a href="#release-分支" class="headerlink" title="release 分支"></a>release 分支</h2><ul><li>可能派发自：develop</li><li>必须合并回：develop 和 master</li><li>分支命名规范：release-*</li></ul><p>Release 分支用来支持新的生产环境发布的准备工作。允许在最后阶段产生提交点(dotting i’s)和交汇点(crossing t’s)。而且允许小幅度的问题修复以及准备发布时的meta数据(比如版本号、发布日期等)。在 release 分支做了上述这些工作之后，develop 分支会被“翻篇儿”，开始接收下一次发布的新特性。</p><p>我们选择(几近)完成所有预期的开发的时候，作为从 develop 派发出 release 分支的时机。最起码所有准备构建发布的功能都已经及时合并到了 develop 分支。而往后才会发布的功能则不应该合并到 develop 分支——他们必须等到 release 分支派发出去之后再做合并。</p><p>在一个 release 分支的开始，我们就赋予其一个明确的版本号。直到该分支创建之前，develop 分支上的描述都是“下一次”release 的改动，但这个“下一次”release 其实也没说清楚是 0.3 release 还是 1.0 release。而在一个 release 分支的开始时这一点就会确定。这将成为有关项目版本号晋升的一个守则。</p><h3 id="创建一个-release-分支"><a href="#创建一个-release-分支" class="headerlink" title="创建一个 release 分支"></a>创建一个 release 分支</h3><p>Release 分支派发自 develop 分支。比如，我们当前的生产环境发布的版本是 1.1.5，马上有一个 release 要发布了。develop 分支已经为“下一次”release 做好了准备，并且我们已经决定把新的版本号定为 1.2 (而不是 1.1.6 或 2.0)。所以我们派发一个 release 分支并以新的版本号为其命名：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git checkout -b <span class="hljs-keyword">release</span><span class="hljs-number">-1.2</span> develop<br>Switched <span class="hljs-keyword">to</span> a <span class="hljs-built_in">new</span> branch &quot;release-1.2&quot;<br>$ ./bump-<span class="hljs-keyword">version</span>.sh <span class="hljs-number">1.2</span><br>Files modified successfully, <span class="hljs-keyword">version</span> bumped <span class="hljs-keyword">to</span> <span class="hljs-number">1.2</span>.<br>$ git <span class="hljs-keyword">commit</span> -a -m &quot;Bumped version number to 1.2&quot;<br>[<span class="hljs-keyword">release</span><span class="hljs-number">-1.2</span> <span class="hljs-number">74</span>d9424] Bumped <span class="hljs-keyword">version</span> number <span class="hljs-keyword">to</span> <span class="hljs-number">1.2</span><br><span class="hljs-number">1</span> files changed, <span class="hljs-number">1</span> insertions(+), <span class="hljs-number">1</span> deletions(-)<br><br></code></pre></td></tr></table></figure><p>创建好并切换到新的分支之后，我们完成对版本号的晋升。这里的 bump-version.sh是一个虚构的用来改变代码库中某些文件以反映新版本的 shell 脚本。(当然你也可以手动完成这些改变——重点是有些文件发生了改变)然后，晋升了的版本号会被提交。</p><p>这个新的分支会存在一段时间，直到它确实发布出去了为止。期间可能会有 bug 修复(这比在 develop 做更合理)。但我们严格禁止在此开发庞大的新特性，它们应该合并到 develop 分支，并放入下次发布。</p><h3 id="完成一个-release-分支"><a href="#完成一个-release-分支" class="headerlink" title="完成一个 release 分支"></a>完成一个 release 分支</h3><p>当 release 分支真正发布成功之后，还有些事情需要收尾。首先，release 分支会被合并到 master (别忘了，master 上的每一次提交都代表一个真正的新的发布)；然后，为master 上的这次提交打一个 tag，以便作为版本历史的重要参考；最后，还要把 release 分支产生的改动合并回 develop，以便后续的发布同样包含对这些 bug 的修复。</p><p>前两部在 git 下是这样操作的：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br>$ git merge --no-ff release-<span class="hljs-number">1.2</span><br>Merge made by recursive<br>(Summary of changes)<br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> <span class="hljs-number">1.2</span><br><br></code></pre></td></tr></table></figure><p>现在发布工作已经完成了，同时 tag 也打好了，用在未来做参考。</p><p>补充：你也可以通过 -s 或 -u &lt;key&gt; 标记打 tag。</p><p>为了保留 release 分支里的改动记录，我们需要把这些改动合并回 develop。git 操作如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git checkout develop<br>Switched <span class="hljs-keyword">to</span> branch <span class="hljs-string">&#x27;develop&#x27;</span><br>$ git merge <span class="hljs-comment">--no-ff release-1.2</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">recursive</span>.<br>(<span class="hljs-keyword">Summary</span> <span class="hljs-keyword">of</span> changes)<br><br></code></pre></td></tr></table></figure><p>这一步有可能导致冲突的发生(只是有理论上的可能性，因为我们已经改变了版本号)，一旦发现，解决冲突然后提交就好了。</p><p>现在我们真正完成了一个 release 分支，该把它删掉了，因为它的使命已经完成了：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ git branch -d release<span class="hljs-number">-1.2</span><br>Deleted branch release<span class="hljs-number">-1.2</span> (was ff452fe).<br><br></code></pre></td></tr></table></figure><h2 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="hotfix 分支"></a>hotfix 分支</h2><p><img src="http://img.blog.csdn.net/20151229150414124">\</p><ul><li>可能派发自：master</li><li>必须合并回：develop 和 master</li><li>分支命名规范：hotfix-*</li></ul><p>Hotfix 分支和 release 分支非常类似，因为他们都意味着会产生一个新的生产环境的发布，尽管 hotfix 分支不是先前就计划好的。他们在实时的生产环境版本出现意外需要快速响应时，从 master 分支相应的 tag 被派发。</p><p>我们这样做的根本原因，是为了让团队其中一个人来快速修复生产环境的问题，其他成员可以按工作计划继续工作下去而不受太大影响。</p><h3 id="创建一个-hotfix-分支"><a href="#创建一个-hotfix-分支" class="headerlink" title="创建一个 hotfix 分支"></a>创建一个 hotfix 分支</h3><p>Hotfix 分支创建自 master 分支。例如，假设 1.2 版本是目前的生产环境且出现了一个严重的 bug，但是目前的 develop 并不足够稳定。那么我们可以派发出一个 hotfix 分支来开始我们的修复工作：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ git checkout -<span class="hljs-keyword">b</span> hotfix-<span class="hljs-number">1.2</span>.<span class="hljs-number">1</span> master<br>Switched <span class="hljs-keyword">to</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> branch <span class="hljs-string">&quot;hotfix-1.2.1&quot;</span><br>$ ./bump-<span class="hljs-keyword">version</span>.<span class="hljs-keyword">sh</span> <span class="hljs-number">1.2</span>.<span class="hljs-number">1</span><br>Files modified successfully, <span class="hljs-keyword">version</span> bumped <span class="hljs-keyword">to</span> <span class="hljs-number">1.2</span>.<span class="hljs-number">1</span>.<br>$ git commit -<span class="hljs-keyword">a</span> -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;Bumped version number to 1.2.1&quot;</span><br>[hotfix-<span class="hljs-number">1.2</span>.<span class="hljs-number">1</span> <span class="hljs-number">41</span>e61bb] Bumped <span class="hljs-keyword">version</span> <span class="hljs-keyword">number</span> <span class="hljs-keyword">to</span> <span class="hljs-number">1.2</span>.<span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">files</span> changed, <span class="hljs-number">1</span> insertions(+), <span class="hljs-number">1</span> deletions(-)<br><br></code></pre></td></tr></table></figure><p>别忘了在派发出分支之后晋升版本号！</p><p>然后，修复 bug，提交改动。通过一个或多个提交都可以。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git commit -m &quot;Fixed severe production problem&quot;<br><span class="hljs-selector-attr">[hotfix-1.2.1 abbe5d6]</span> Fixed severe production problem<br><span class="hljs-number">5</span> files changed, <span class="hljs-number">32</span> <span class="hljs-built_in">insertions</span>(+), <span class="hljs-number">17</span> <span class="hljs-built_in">deletions</span>(-)<br><br></code></pre></td></tr></table></figure><h3 id="完成一个-hotfix-分支"><a href="#完成一个-hotfix-分支" class="headerlink" title="完成一个 hotfix 分支"></a>完成一个 hotfix 分支</h3><p>当我们完成之后，对 bug 的修复需要合并回 master，同时也需要合并回 develop，以保证接下来的发布也都已经解决了这个 bug。这和 release 分支的完成方式是完全一样的。</p><p>首先，更新 master 并为本次发布打一个 tag：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br>$ git merge --no-ff hotfix-<span class="hljs-number">1.2</span>.<span class="hljs-number">1</span><br>Merge made by recursive<br>(Summary of changes)<br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> <span class="hljs-number">1.2</span>.<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>补充：你也可以通过 -s 或 -u &lt;key&gt; 标记打 tag。</p><p>然后，把已修复的 bug 合并到 develop：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git checkout develop<br>Switched <span class="hljs-keyword">to</span> branch <span class="hljs-string">&#x27;develop&#x27;</span><br>$ git merge <span class="hljs-comment">--no-ff hotfix-1.2.1</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">recursive</span><br>(<span class="hljs-keyword">Summary</span> <span class="hljs-keyword">of</span> changes)<br><br></code></pre></td></tr></table></figure><p>这个规矩的一个额外之处是：如果此时已经存在了一个 release 分支，那么 hotfix 的改变需要合并到这个 release 分支，而不是 develop 分支。因为把对 bug 的修复合并回 release 分支之后，release 分支最终还是会合并回 develop 分支的。(如果在 develop 分支中立刻需要对这个 bug 的修复，且等不及 release 分支合并回来，则你还是可以直接合并回 develop 分支的，这是绝对没问题的)</p><p>最后，删掉这个临时的分支：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ git <span class="hljs-keyword">branch </span>-d hotfix<span class="hljs-number">-1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span><br>Deleted <span class="hljs-keyword">branch </span>hotfix<span class="hljs-number">-1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span> (was abbe5d6).<br><br></code></pre></td></tr></table></figure><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>其实这个分支模型里没有什么新奇的东西。文章开头的那张大图对我们的项目来说非常有用。它非常易于团队成员理解这个优雅有效的模型，并在团队内部达成共识。</p><p>这里还有一份那张大图的 <a href="http://nvie.com/files/Git-branching-model.pdf">高清PDF版本</a>，你可以把它当做手册放在手边快速浏览。</p><p>补充：还有，如果你们需要的话，这里还有一份 <a href="http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip">Keynote 版本</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.Git 常用命令</title>
    <link href="/2023/02/01/13.Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/02/01/13.Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-clone命令用法"><a href="#Git-clone命令用法" class="headerlink" title="Git clone命令用法"></a>Git clone命令用法</h1><p>git clone是git中常用的命令，其作用是将存储库克隆到新目录中。为克隆的存储库中的每个分支创建远程跟踪分支(使用git branch -r可见)，并从克隆检出的存储库作为当前活动分支的初始分支。</p><p>在克隆之后，没有参数的普通git提取将更新所有远程跟踪分支，并且没有参数的git pull将另外将远程主分支合并到当前主分支(如果有的话)。</p><p>此默认配置通过在refs&#x2F;remotes&#x2F;origin下创建对远程分支头的引用，并通过初始化remote.origin.url和remote.origin.fetch配置变量来实现。</p><p>执行远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。</p><pre><code class="hljs">$ git clone &lt;版本库的网址&gt;</code></pre><p>比如，克隆jQuery的版本库。</p><pre><code class="hljs">$ git clone http://github.com/jquery/jquery.git</code></pre><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。</p><pre><code class="hljs">$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code></pre><p>git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等。</p><p>   </p><p>在默认情况下，Git会把”Git URL”里最后一级目录名的’.git’的后辍去掉,做为新克隆(clone)项目的目录名: (例如. git clone <a href="http://git.kernel.org/linux/kernel/git/torvalds/linux-2.6.git">http://git.kernel.org/linux/kernel/git/torvalds/linux-2.6.git</a> 会建立一个目录叫’linux-2.6’)\</p><pre><code class="hljs">$ git clone http[s]://example.com/path/to/repo.git$ git clone http://git.oschina.net/yiibai/sample.git$ git clone ssh://example.com/path/to/repo.git$ git clone git://example.com/path/to/repo.git$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git$ git clone rsync://example.com/path/to/repo.git</code></pre><p>SSH协议还有另一种写法。</p><pre><code class="hljs">$ git clone [user@]example.com:path/to/repo.git</code></pre><p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。</p><p><strong>应用场景示例</strong></p><p>从上游克隆下来：</p><pre><code class="hljs">$ git clone git://git.kernel.org/pub/scm/.../linux.git mydir$ cd mydir$ make # 执行代码或其它命令</code></pre><p>在当前目录中使用克隆，而无需检出：</p><pre><code class="hljs">$ git clone -l -s -n . ../copy$ cd ../copy$ git show-branch</code></pre><p>从现有本地目录借用从上游克隆：</p><pre><code class="hljs">$ git clone --reference /git/linux.git     git://git.kernel.org/pub/scm/.../linux.git     mydir$ cd mydir</code></pre><p>创建一个裸存储库以将您的更改发布给公众：</p><pre><code class="hljs">$ git clone --bare -l /home/proj/.git /pub/scm/proj.git</code></pre><h1 id="Git-push命令用法"><a href="#Git-push命令用法" class="headerlink" title="Git push命令用法"></a>Git push命令用法</h1><p>git push是Git中常用的命令，其作用是将本地分支的更新推送到远程主机。</p><p><strong>git push格式：</strong></p><p>git push的格式和git pull类似：</p><pre><code class="hljs">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre><p>注意：</p><p>分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</p><p><strong>git push常见用法：</strong></p><pre><code class="hljs">$ git push origin master</code></pre><p>该命令的作用是将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p><pre><code class="hljs">$ git push origin :master# 等同于$ git push origin --delete master</code></pre><p>上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p><pre><code class="hljs">$ git push origin</code></pre><p>上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。</p><pre><code class="hljs">$ git push</code></pre><p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。</p><pre><code class="hljs">$ git push -u origin master</code></pre><p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p><p>不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。</p><pre><code class="hljs">$ git config --global push.default matching# 或者$ git config --global push.default simple</code></pre><p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p><pre><code class="hljs">$ git push --all origin</code></pre><p>上面命令表示，将所有本地分支都推送到origin主机。</p><p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p><pre><code class="hljs">$ git push --force origin</code></pre><p>上面命令使用–force选项，结果导致在远程主机产生一个”非直进式”的合并(non-fast-forward merge)。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p><p>最后，git push不会推送标签(tag)，除非使用–tags选项。</p><pre><code class="hljs">$ git push origin --tags</code></pre><p>有时候当远程xxx分支被删掉了后，用git branch -a 你还可以看到本地还有remote&#x2F;origin&#x2F;xxx这个分支，那么你可以使用git fetch -p 这个命令可以帮你同步最新的远程分支，并删掉本地被删了的远程分支。</p><h1 id="Git-merge命令用法"><a href="#Git-merge命令用法" class="headerlink" title="Git merge命令用法"></a>Git merge命令用法</h1><p>git merge 是在 Git 中使用比较频繁的一个命令，其主要用于将两个或两个以上的开发历史加入(合并)一起。本文就为大家带来 git merge 命令的常见用法。</p><p><strong>git merge三种语法：</strong></p><pre><code class="hljs">git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]    [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] [-S[&lt;keyid&gt;]]    [--[no-]allow-unrelated-histories]    [--[no-]rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt;…?]git merge --abortgit merge --continue</code></pre><p><strong>git merge用途</strong></p><p>git-merge 命令是用于从指定的 commit(s) 合并到当前分支的操作。</p><blockquote><p>注：这里的指定 commit(s) 是指从这些历史 commit 节点开始，一直到当前分开的时候。</p></blockquote><p>1、用于 git-pull 中，来整合另一代码仓库中的变化（即：git pull &#x3D; git fetch + git merge）</p><p>2、用于从一个分支到另一个分支的合并</p><p>假设下图中的历史节点存在，并且当前所在的分支为“master”：</p><p><img src="https://atts.w3cschool.cn/attachments/image/20180514/1526277109168159.png" alt="1" title="1"></p><p>那么 ​<code>git merge topic</code>​ 命令将会把在 master 分支上二者共同的节点（E节点）之后分离的节点（即 topic 分支的A B C节点）重现在 master 分支上，直到topic分支当前的 commit 节点（C节点），并位于master分支的顶部。并且沿着 master 分支和 topic 分支创建一个记录合并结果的新节点，该节点带有用户描述合并变化的信息。</p><p>即下图中的H节点，C 节点和 G 节点都是 H 节点的父节点。</p><p><img src="https://atts.w3cschool.cn/attachments/image/20180514/1526277117447233.png" alt="2" title="2"></p><p><strong>git merge &lt;msg&gt; HEAD &lt;commit&gt;…命令</strong></p><p>该命令的存在是由于历史原因，在新版本中不应该使用它，应该使用git merge -m &lt;msg&gt; &lt;commit&gt;….进行替代</p><p><strong>git merge –abort命令</strong></p><p>该命令仅仅在合并后导致冲突时才使用。git merge –abort 将会抛弃合并过程并且尝试重建合并前的状态。但是，当合并开始时如果存在未 commit 的文件，git merge –abort在某些情况下将无法重现合并前的状态。（特别是这些未 commit 的文件在合并的过程中将会被修改时）</p><p>警告：</p><p>运行 git-merge 时含有大量的未 commit 文件很容易让你陷入困境，这将使你在冲突中难以回退。因此非常不鼓励在使用 git-merge 时存在未 commit 的文件，建议使用 git-stash 命令将这些未 commit 文件暂存起来，并在解决冲突以后使用 git stash pop 把这些未 commit 文件还原出来。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06. Git 分支管理</title>
    <link href="/2023/02/01/06.Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <url>/2023/02/01/06.Git%20%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p>创建分支命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch (branchname)<br></code></pre></td></tr></table></figure><p>切换分支命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout (branchname)<br></code></pre></td></tr></table></figure><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge <br></code></pre></td></tr></table></figure><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><h2 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h2><h3 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h3><p>列出分支基本命令：</p><pre><code class="hljs">git branch</code></pre><p>没有参数时，git branch 会列出你在本地的分支。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* <span class="hljs-keyword">master</span><br><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做”master”的分支，并且该分支是当前分支。</p><p>当你执行 git init 的时候，缺省情况下 Git 就会为你创建”master”分支。</p><p>如果我们要手动创建一个分支，并切换过去。执行 git branch (branchname) 即可。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch testing<br>$ git branch<br>* <span class="hljs-keyword">master</span><br>  <span class="hljs-title">testing</span><br><br></code></pre></td></tr></table></figure><p>现在我们可以看到，有了一个新分支 testing。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了”testing”分支，Git 将还原你的工作目录到你创建分支时候的样子</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">ls</span><br>README<br>$ <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;w3cschool.cn&#x27;</span> &gt; test.txt<br>$ git <span class="hljs-built_in">add</span> .<br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&#x27;add test.txt&#x27;</span><br>[master <span class="hljs-number">048598</span><span class="hljs-keyword">f</span>] <span class="hljs-built_in">add</span> test.txt<br> <span class="hljs-number">2</span> <span class="hljs-keyword">files</span> changed, <span class="hljs-number">1</span> insertion(+), <span class="hljs-number">3</span> deletions(-)<br> <span class="hljs-keyword">delete</span> <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> hello.php<br> create <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> test.txt<br>$ <span class="hljs-keyword">ls</span><br>README       test.txt<br>$ git checkout testing<br>Switched <span class="hljs-keyword">to</span> branch <span class="hljs-string">&#x27;testing&#x27;</span><br>$ <span class="hljs-keyword">ls</span><br>README      hello.php<br><br></code></pre></td></tr></table></figure><p>当我们切换到”testing”分支的时候，我们添加的新文件test.txt被移除了, 原来被删除的文件hello.php文件又出现了。切换回”master”分支的时候，它们有重新出现了。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git checkout <span class="hljs-keyword">master</span><br><span class="hljs-title">Switched</span> to branch &#x27;<span class="hljs-literal">master</span>&#x27;<br>$ ls<br>README        test.txt<br><br></code></pre></td></tr></table></figure><p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git checkout <span class="hljs-literal">-b</span> newtest<br>Switched to a new branch <span class="hljs-string">&#x27;newtest&#x27;</span><br><span class="hljs-variable">$</span> git <span class="hljs-built_in">rm</span> test2.txt <br><span class="hljs-built_in">rm</span> <span class="hljs-string">&#x27;test2.txt&#x27;</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>README      test.txt<br><span class="hljs-variable">$</span> git commit <span class="hljs-literal">-am</span> <span class="hljs-string">&#x27;removed test2.txt&#x27;</span><br>[<span class="hljs-type">newtest</span> <span class="hljs-number">556</span><span class="hljs-type">f0a0</span>] removed test2.txt<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> deletion(-)<br> delete mode <span class="hljs-number">100644</span> test2.txt<br><span class="hljs-variable">$</span> git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>README        test.txt    test2.txt<br><br></code></pre></td></tr></table></figure><p>如你所见，我们创建了一个分支，在该分支的上下文中移除了一些文件，然后切换回我们的主分支，那些文件又回来了。</p><p>使用分支将工作切分开来，从而让我们能够在不同上下文中做事，并来回切换。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除分支命令：</p><pre><code class="hljs">git branch -d (branchname)</code></pre><p>例如我们要删除”testing”分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* <span class="hljs-keyword">master</span><br>  <span class="hljs-title">testing</span><br>$ git branch -d testing<br>Deleted branch testing (was <span class="hljs-number">85</span>fc7e7).<br>$ git branch<br>* <span class="hljs-keyword">master</span><br><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p><pre><code class="hljs">git merge</code></pre><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git branch<br><span class="hljs-comment">* master</span><br>  newtest<br><span class="hljs-symbol">$</span> ls<br>README       test.txt    test2.txt<br><span class="hljs-symbol">$</span> git merge newtest<br><span class="hljs-function"><span class="hljs-title">Updating</span></span> <span class="hljs-number">2e082</span>b7.<span class="hljs-number">.556</span>f0a0<br>Fast-forward<br> test2.txt | <span class="hljs-number">1</span> -<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> deletion(-)<br> delete mode <span class="hljs-number">100644</span> test2.txt<br><span class="hljs-symbol">$</span> ls<br>README      test.txt<br><br></code></pre></td></tr></table></figure><p>以上实例中我们将 newtest 分支合并到主分支去，test2.txt 文件被删除。</p><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> cat test.txt<br>w3cschool.cn<br><br></code></pre></td></tr></table></figure><p>首先，我们创建一个叫做”change_site”的分支，切换过去，我们将内容改为 <a href="http://www.w3cschool.cn/">www.w3cschool.cn</a> 。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git checkout -<span class="hljs-selector-tag">b</span> change_site<br>Switched to <span class="hljs-selector-tag">a</span> new branch <span class="hljs-string">&#x27;change_site&#x27;</span><br>$ vim test<span class="hljs-selector-class">.txt</span> <br>$ head -<span class="hljs-number">1</span> test<span class="hljs-selector-class">.txt</span> <br>www<span class="hljs-selector-class">.w3cschool</span><span class="hljs-selector-class">.cn</span><br>$ git commit -am <span class="hljs-string">&#x27;changed the site&#x27;</span><br><span class="hljs-selector-attr">[change_site d7e7346]</span> changed the site<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> <span class="hljs-built_in">insertion</span>(+), <span class="hljs-number">1</span> <span class="hljs-built_in">deletion</span>(-)<br> <br></code></pre></td></tr></table></figure><p>将修改的内容提交到 “change_site” 分支中。 现在，假如切换回 “master” 分支我们可以看内容恢复到我们修改前的，我们再次修改test.txt文件。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>$ head -<span class="hljs-number">1</span> test<span class="hljs-selector-class">.txt</span> <br>w3cschool<span class="hljs-selector-class">.cn</span><br>$ vim test<span class="hljs-selector-class">.txt</span> <br>$ cat test<span class="hljs-selector-class">.txt</span><br>w3cschool<span class="hljs-selector-class">.cn</span><br>新增加一行<br>$ git diff<br>diff <span class="hljs-attr">--git</span> a/test<span class="hljs-selector-class">.txt</span> b/test<span class="hljs-selector-class">.txt</span><br>index <span class="hljs-number">704</span>cce7.<span class="hljs-selector-class">.f84c2a4</span> <span class="hljs-number">100644</span><br>--- a/test<span class="hljs-selector-class">.txt</span><br>+++ b/test<span class="hljs-selector-class">.txt</span><br>@@ -<span class="hljs-number">1</span> +<span class="hljs-number">1</span>,<span class="hljs-number">2</span> @@<br> w3cschool<span class="hljs-selector-class">.cn</span><br>+新增加一行<br>$ git commit -am <span class="hljs-string">&#x27;新增加一行&#x27;</span><br><span class="hljs-selector-attr">[master 14b4dca]</span> 新增加一行<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> <span class="hljs-built_in">insertion</span>(+)<br> <br></code></pre></td></tr></table></figure><p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> $ git merge change_site<br>Auto-merging test.txt<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> test.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br>$ cat test.txt <br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD w3cschool.cn 新增加一行 ======= www.w3cschool.cn &gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site<br><br></code></pre></td></tr></table></figure><p>我们将前一个分支合并到 “master” 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ vim test<span class="hljs-selector-class">.txt</span> <br>$ cat test<span class="hljs-selector-class">.txt</span> <br>www<span class="hljs-selector-class">.w3cschool</span><span class="hljs-selector-class">.cn</span><br>新增加一行<br>$ git diff<br>diff <span class="hljs-attr">--cc</span> test<span class="hljs-selector-class">.txt</span><br>index f84c2a4,bccb7c2..<span class="hljs-number">0000000</span><br>--- a/test<span class="hljs-selector-class">.txt</span><br>+++ b/test<span class="hljs-selector-class">.txt</span><br>@@@ -<span class="hljs-number">1</span>,<span class="hljs-number">2</span> -<span class="hljs-number">1</span>,<span class="hljs-number">1</span> +<span class="hljs-number">1</span>,<span class="hljs-number">2</span> @@@<br>- w3cschool<span class="hljs-selector-class">.cn</span><br>+ www<span class="hljs-selector-class">.w3cschool</span><span class="hljs-selector-class">.cn</span><br> +新增加一行<br><br></code></pre></td></tr></table></figure><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git status -s<br><span class="hljs-title class_">UU</span> test.txt<br><span class="hljs-variable">$ </span>git add test.txt <br><span class="hljs-variable">$ </span>git status -s<br>M  test.txt<br><span class="hljs-variable">$ </span>git commit<br>[master <span class="hljs-number">88</span>afe0e] <span class="hljs-title class_">Merge</span> branch <span class="hljs-string">&#x27;change_site&#x27;</span><br><br></code></pre></td></tr></table></figure><p>现在我们成功解决了合并中的冲突，并提交了结果。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05.Git 基本操作</title>
    <link href="/2023/02/01/05.Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/02/01/05.Git%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><h2 id="获取与创建项目命令"><a href="#获取与创建项目命令" class="headerlink" title="获取与创建项目命令"></a>获取与创建项目命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。</p><p>在目录中执行 git init，就可以创建一个 Git 仓库了。比如我们创建 w3cschoolcc 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> w3cschoolcc<br>$ <span class="hljs-built_in">cd</span> w3cschoolcc<br>$ git init<br>Initialized empty Git repository <span class="hljs-keyword">in</span> /www/w3cschoolcc/.git/<br><span class="hljs-comment"># 在 /www/w3cschoolcc/.git/ 目录初始化空 Git 仓库完毕。</span><br></code></pre></td></tr></table></figure><p>在你可以看到在你的项目目录中有个 .git 的子目录。 这就是你的 Git 仓库了，所有有关你的此项目的快照数据都存放在这里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -a<br>.    ..  .git<br></code></pre></td></tr></table></figure><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。</p><p>如果你需要与他人合作一个项目，或者想要复制一个项目，看看代码，你就可以克隆那个项目。 执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> [url]<br></code></pre></td></tr></table></figure><p>[url] 为你想要复制的项目，就可以了。</p><p>例如我们克隆 Github 上的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git://github.com/schacon/simplegit.git<br>Initialized empty Git repository <span class="hljs-keyword">in</span> /private/tmp/simplegit/.git/<br>remote: Counting objects: 100, <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (86/86), <span class="hljs-keyword">done</span>.<br>remote: Total 100 (delta 35), reused 0 (delta 0)<br>Receiving objects: 100% (100/100), 9.51 KiB, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (35/35), <span class="hljs-keyword">done</span>.<br>$ <span class="hljs-built_in">cd</span> simplegit/<br>$ <span class="hljs-built_in">ls</span><br>README   Rakefile lib<br><br></code></pre></td></tr></table></figure><p>上述操作将复制该项目的全部记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -a<br>.        ..       .git     README   Rakefile lib<br>$ <span class="hljs-built_in">cd</span> .git<br>$ <span class="hljs-built_in">ls</span><br>HEAD        description info        packed-refs<br>branches    hooks       logs        refs<br>config      index       objects<br></code></pre></td></tr></table></figure><p>默认情况下，Git 会按照你提供的 URL 所指示的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 &#x2F; 之后的项目名称。如果你想要一个不一样的名字， 你可以在该命令后加上你想要的名称。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>git add 命令可将该文件添加到缓存，如我们添加以下两个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> README<br>$ <span class="hljs-built_in">touch</span> hello.php<br>$ <span class="hljs-built_in">ls</span><br>README      hello.php<br>$ git status -s<br>?? README<br>?? hello.php<br>$ <br><br></code></pre></td></tr></table></figure><p>git status 命令用于查看项目的当前状态。</p><p>接下来我们执行 git add 命令来添加文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add README hello.php <br><br></code></pre></td></tr></table></figure><p>现在我们再执行 git status，就可以看到这两个文件已经加上去了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status -s<br>A  README<br>A  hello.php<br>$ <br></code></pre></td></tr></table></figure><p>新项目中，添加所有文件很普遍，可以在当前工作目录执行命令：git add .。</p><p>现在我们改个文件，再执行一下 git status：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim README<br>$ git status -s<br>AM README<br>A  hello.php<br><br></code></pre></td></tr></table></figure><p>“AM” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们在执行 git add 命令将其添加到缓存中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add .<br>$ git status -s<br>A  README<br>A  hello.php<br><br></code></pre></td></tr></table></figure><p>当你要将你的修改包含在即将提交的快照里的时候，需要执行 git add。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>git status 以查看在你上次提交之后是否有修改。</p><p>我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br>On branch master<br><br>Initial commit<br><br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)<br><br>  new file:   README<br>    new file:   hello.php<br></code></pre></td></tr></table></figure><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>执行 git diff 来查看执行 git status 的结果的详细信息。</p><p>git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p><ul><li>尚未缓存的改动：git diff</li><li>查看已缓存的改动： git diff –cached</li><li>查看已缓存的与未缓存的所有改动：git diff HEAD</li><li>显示摘要而非整个 diff：git diff –stat</li></ul><p>在 hello.php 文件中输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.w3cschool.cn&#x27;</span>; ?&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status -s<br>A  README<br>AM hello.php<br>$ git diff<br>diff --git a/hello.php b/hello.php<br>index e69de29..d1a9166 100644<br>--- a/hello.php<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+&lt;?php +<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.w3cschool.cn&#x27;</span>; +?&gt;<br><br></code></pre></td></tr></table></figure><p>git status显示你上次提交更新至后所更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。</p><p>接下来我们来查看下 git diff –cached 的执行效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add hello.php <br>$ git status -s<br>A  README<br>A  hello.php<br>$ git diff --cached<br>diff --git a/README b/README<br>new file mode 100644<br>index 0000000..704cce7<br>--- /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+w3cschool.cn<br>diff --git a/hello.php b/hello.php<br>new file mode 100644<br>index 0000000..d1a9166<br>--- /dev/null<br>+++ b/hello.php<br>@@ -0,0 +1,3 @@<br>+&lt;?php +<span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;www.w3cschool.cn&#x27;</span>; +?&gt;<br><br></code></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>使用 git add 命令将想要快照的内容写入了缓存， 而执行 git commit 记录缓存区的快照。</p><p>Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&#x27;w3cschool&#x27;</span><br>$ git config --global user.email w3c@w3cschool.cn<br><br></code></pre></td></tr></table></figure><p>接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add hello.php<br>$ git status -s<br>A  README<br>A  hello.php<br>$ git commit -m <span class="hljs-string">&#x27;test comment from w3cschool.cn&#x27;</span><br>[master (root-commit) 85fc7e7] <span class="hljs-built_in">test</span> comment from w3cschool.cn<br> 2 files changed, 4 insertions(+)<br> create mode 100644 README<br> create mode 100644 hello.php<br> <br></code></pre></td></tr></table></figure><p>现在我们已经记录了快照。如果我们再执行 git status:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"> $ git status<br><span class="hljs-comment"># On branch master</span><br>nothing to commit (working directory clean)<br><br></code></pre></td></tr></table></figure><p>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”干净的工作目录”。</p><p>如果你没有设置 -m 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。屏幕会像这样：</p><p># Please enter the commit message for your changes. Lines starting # with ‘#’ will be ignored, and an empty message aborts the commit. # On branch master # Changes to be committed: # (use “git reset HEAD …” to unstage) # # modified: hello.php # ~ ~ “.git&#x2F;COMMIT_EDITMSG” 9L, 257C</p><p>如果你觉得 git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步。命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -a<br><br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -am <span class="hljs-string">&#x27;changes to hello file&#x27;</span><br>[master 78b2670] changes to hello file<br> 1 files changed, 2 insertions(+), 1 deletions(-)<br> <br></code></pre></td></tr></table></figure><h3 id="git-reset-HEAD"><a href="#git-reset-HEAD" class="headerlink" title="git reset HEAD"></a>git reset HEAD</h3><p>git reset HEAD 命令用于取消缓存已缓存的内容。</p><p>这里我们有两个最近提交之后又有所改动的文件。我们将两个都缓存，并取消缓存其中一个。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status -s<br> M README<br> M hello.php<br>$ git add .<br>$ git status -s<br>M  README<br>M  hello.pp<br>$ git reset HEAD -- hello.php <br>Unstaged changes after reset:<br>M hello.php<br>$ git status -s<br>M  README<br> M hello.php<br> <br></code></pre></td></tr></table></figure><p>现在你执行 git commit 将只记录 README 文件的改动，并不含现在并不在缓存中的 hello.rb。</p><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>git rm 将文件从缓存区中移除。</p><p>如我们删除 hello.php文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"> $ git <span class="hljs-built_in">rm</span> hello.php <br><span class="hljs-built_in">rm</span> <span class="hljs-string">&#x27;hello.php&#x27;</span><br>$ <span class="hljs-built_in">ls</span><br>README<br><br></code></pre></td></tr></table></figure><p>默认情况下，git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 如果要在工作目录中留着该文件，可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> --cached。<br></code></pre></td></tr></table></figure><h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>git mv 命令做得所有事情就是 git rm –cached， 重命名磁盘上的文件，然后再执行 git add 把新文件添加到缓存区。因此，虽然有 git mv 命令，但它有点多余 。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09.Git 远程仓库</title>
    <link href="/2023/02/01/09.Git%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2023/02/01/09.Git%20%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>Git 并不像 SVN 那样有个中心服务器。</p><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p>本例使用了 Github 作为远程仓库，你可以先阅读我们的 <a href="https://www.w3cschool.cn/w3cnote/git-guide.html">Github 简明教程。</a></p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add [shortname] [url]<br><br></code></pre></td></tr></table></figure><p>本例以Github为例作为远程仓库，如果你没有Github可以在官网<a href="https://github.com/">https://github.com/</a>注册。</p><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p><p>使用以下命令生成SSH Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>后面的your_email@youremail.com改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在~&#x2F;下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。</p><p>回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。</p><p><img src="https://atts.w3cschool.cn/attachments/day_160929/201609291616226480.png"></p><p>为了验证是否成功，输入以下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ ssh -T git@github.com<br>Hi WongJay! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br><br></code></pre></td></tr></table></figure><p>以下命令说明我们已成功连上 Github。</p><p>之后登录后点击” New repository “ 如下图所示：</p><p><img src="https://atts.w3cschool.cn/attachments/day_160929/201609291556118344.png"></p><p>之后在在Repository name 填入 w3cschool.cn(远程仓库名) ，其他保持默认设置，点击”Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://atts.w3cschool.cn/attachments/day_160929/201609291555152907.png"></p><p>创建成功后，显示如下信息：</p><p><img src="https://atts.w3cschool.cn/attachments/day_160929/201609291557318743.png"></p><p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的仓库下运行命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ ls<br>README<br>W3Cschool教程测试.txt<br>test.txt<br>$ git remote add origin git@github.com:WongJay/w3cschool.cn.git<br>$ git push -u origin <span class="hljs-keyword">master</span><br><span class="hljs-title">Counting</span> objects: <span class="hljs-number">21</span>, done.<br>Delta compression using up to <span class="hljs-number">4</span> threads.<br>Compressing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">15</span>/<span class="hljs-number">15</span>), done.<br>Writing objects: <span class="hljs-number">100</span>% (<span class="hljs-number">21</span>/<span class="hljs-number">21</span>), <span class="hljs-number">1.73</span> KiB | <span class="hljs-number">0</span> bytes/s, done.<br>Total <span class="hljs-number">21</span> (delta <span class="hljs-number">4</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>)<br>To git@github.com:WongJay/w3cschool.cn.git<br> * [new branch]      <span class="hljs-keyword">master</span> <span class="hljs-title">-&gt; master</span><br>Branch <span class="hljs-keyword">master</span> <span class="hljs-title">set</span> up to track remote branch <span class="hljs-keyword">master</span> <span class="hljs-title">from</span> origin.<br><br></code></pre></td></tr></table></figure><p>以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。</p><p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到Github上：</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03.Git 工作区、暂存区和版本库</title>
    <link href="/2023/02/01/03.Git%20%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93/"/>
    <url>/2023/02/01/03.Git%20%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E7%89%88%E6%9C%AC%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><strong>工作区</strong>：就是你在电脑里能看到的目录</li><li><strong>暂存区</strong>：英文叫stage, 或index。一般存放在”git目录”下的index文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）</li><li><strong>版本库</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库</li></ul><!----><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p><p><img src="https://atts.w3cschool.cn/attachments/day_160929/201609291519223166.png"></p><p>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。</p><p>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</p><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git&#x2F;objects” 目录下，里面包含了创建的各种对象及内容。</p><p>当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p><p>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p><p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p><p>当执行 “git rm –cached &lt;file&gt;” 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p><p>当执行 “git checkout .” 或者 “git checkout – &lt;file&gt;” 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p><p>当执行 “git checkout HEAD .” 或者 “git checkout HEAD &lt;file&gt;” 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02.Git 工作流程</title>
    <link href="/2023/02/01/02.Git%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/02/01/02.Git%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><p>下图展示了 Git 的工作流程：</p><p><img src="https://atts.w3cschool.cn/attachments/day_160929/201609291518243574.png"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.Git 安装配置</title>
    <link href="/2023/02/01/01.Git%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/02/01/01.Git%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>Git 各平台安装包下载地址为：<a href="https://git-scm.com/downloads">http://git-scm.com/downloads</a></p><h2 id="Linux-平台上安装"><a href="#Linux-平台上安装" class="headerlink" title="Linux 平台上安装"></a>Linux 平台上安装</h2><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p><p>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p><h3 id="Debian-x2F-Ubuntu"><a href="#Debian-x2F-Ubuntu" class="headerlink" title="Debian&#x2F;Ubuntu"></a>Debian&#x2F;Ubuntu</h3><p>Debian&#x2F;Ubuntu Git 安装命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \<br>  libz-dev libssl-dev<br><br>$ apt-get install git-core<br><br>$ git --version<br>git version 1.8.1.2<br></code></pre></td></tr></table></figure><h3 id="Centos-x2F-RedHat"><a href="#Centos-x2F-RedHat" class="headerlink" title="Centos&#x2F;RedHat"></a>Centos&#x2F;RedHat</h3><p>如果你使用的系统是 Centos&#x2F;RedHat 安装命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install curl-devel expat-devel gettext-devel \<br>  openssl-devel zlib-devel<br><br>$ yum -y install git-core<br><br>$ git --version<br>git version 1.7.1<br></code></pre></td></tr></table></figure><h2 id="Windows-平台上安装"><a href="#Windows-平台上安装" class="headerlink" title="Windows 平台上安装"></a>Windows 平台上安装</h2><p>安装包下载地址：<a href="https://gitforwindows.org/">https://gitforwindows.org/</a></p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。</p><p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER</p><p>此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>配置个人的用户名称和电子邮件地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;w3c&quot;</span><br>$ git config --global user.email w3c@w3cschool.cn<br></code></pre></td></tr></table></figure><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git&#x2F;config 文件里。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global core.editor emacs<br></code></pre></td></tr></table></figure><h3 id="差异分析工具"><a href="#差异分析工具" class="headerlink" title="差异分析工具"></a>差异分析工具</h3><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global merge.tool vimdiff<br><br></code></pre></td></tr></table></figure><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p><blockquote><p>当然，你也可以指定使用自己开发的工具。</p></blockquote><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>要检查已有的配置信息，可以使用​<code> git config --list</code>​ 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --list<br>user.name=Scott Chacon<br>user.email=schacon@gmail.com<br>color.status=auto<br>color.branch=auto<br>color.interactive=auto<br>color.diff=auto<br>...<br></code></pre></td></tr></table></figure><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 &#x2F;etc&#x2F;gitconfig 和 ~&#x2F;.gitconfig），不过最终 Git 实际采用的是最后一个。</p><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config user.name<br>Scott Chacon<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08.Git 标签</title>
    <link href="/2023/02/01/08.Git%20%E6%A0%87%E7%AD%BE/"/>
    <url>/2023/02/01/08.Git%20%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 w3cschoolcc 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">0</span> <br><br></code></pre></td></tr></table></figure><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --oneline --decorate --graph<br><span class="hljs-comment">*   88afe0e (HEAD, tag: v1.0, master) Merge branch &#x27;change_site&#x27;</span><br>|\  <br>| * d7e7346 (change_site) changed the site<br><span class="hljs-comment">* | 14b4dca 新增加一行</span><br>|/  <br><span class="hljs-comment">* 556f0a0 removed test2.txt</span><br><span class="hljs-comment">* 2e082b7 add test2.txt</span><br><span class="hljs-comment">* 048598f add test.txt</span><br><span class="hljs-comment">* 85fc7e7 test comment from w3cschool.cn</span><br><br></code></pre></td></tr></table></figure><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git tag -a v0<span class="hljs-number">.9</span> <span class="hljs-number">85</span>fc7e7<br><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --oneline --decorate --graph<br><span class="hljs-comment">*   88afe0e (HEAD, tag: v1.0, master) Merge branch &#x27;change_site&#x27;</span><br>|\  <br>| * d7e7346 (change_site) changed the site<br><span class="hljs-comment">* | 14b4dca 新增加一行</span><br>|/  <br><span class="hljs-comment">* 556f0a0 removed test2.txt</span><br><span class="hljs-comment">* 2e082b7 add test2.txt</span><br><span class="hljs-comment">* 048598f add test.txt</span><br><span class="hljs-comment">* 85fc7e7 (tag: v0.9) test comment from w3cschool.cn</span><br><br></code></pre></td></tr></table></figure><p>如果我们要查看所有标签可以使用以下命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">v0</span>.<span class="hljs-number">9</span><br>v1.<span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>指定标签信息命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> <span class="hljs-tag">&lt;tagname&gt;</span> -m <span class="hljs-string">&quot;w3cschool.cn标签&quot;</span><br><br></code></pre></td></tr></table></figure><p>PGP签名标签命令：</p><pre><code class="hljs">git tag -s &lt;tagname&gt; -m &quot;w3cschool.cn标签&quot;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07.Git 查看提交历史.md</title>
    <link href="/2023/02/01/07.Git%20%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/"/>
    <url>/2023/02/01/07.Git%20%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2/</url>
    
    <content type="html"><![CDATA[<p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p><p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sql">$ git log<br><span class="hljs-keyword">commit</span> <span class="hljs-number">88</span>afe0e02adcdfea6844bb627de97da21eb10af1<br><span class="hljs-keyword">Merge</span>: <span class="hljs-number">14</span>b4dca d7e7346<br>Author: w3cschool <span class="hljs-operator">&lt;</span>w3c<span class="hljs-variable">@w3cschool</span>.cn<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Sun Mar <span class="hljs-number">1</span> <span class="hljs-number">15</span>:<span class="hljs-number">03</span>:<span class="hljs-number">42</span> <span class="hljs-number">2015</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">Merge</span> branch <span class="hljs-string">&#x27;change_site&#x27;</span><br>    <br>    Conflicts:<br>        test.txt<br><br><span class="hljs-keyword">commit</span> <span class="hljs-number">14</span>b4dcadbdc847207651d5a9fae0d315057f346e<br>Author: w3cschool <span class="hljs-operator">&lt;</span>w3c<span class="hljs-variable">@w3cschool</span>.cn<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Sun Mar <span class="hljs-number">1</span> <span class="hljs-number">14</span>:<span class="hljs-number">53</span>:<span class="hljs-number">15</span> <span class="hljs-number">2015</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    新增加一行<br><br><span class="hljs-keyword">commit</span> d7e734640da06055e107eaf29cf350b3f1de1c2c<br>Author: w3cschool <span class="hljs-operator">&lt;</span>w3c<span class="hljs-variable">@w3cschool</span>.cn<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Sun Mar <span class="hljs-number">1</span> <span class="hljs-number">14</span>:<span class="hljs-number">48</span>:<span class="hljs-number">57</span> <span class="hljs-number">2015</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    changed the site<br><br><span class="hljs-keyword">commit</span> <span class="hljs-number">556</span>f0a0637978097b82287ac665a717623b21f3f<br>Author: w3cschool <span class="hljs-operator">&lt;</span>w3c<span class="hljs-variable">@w3cschool</span>.cn<span class="hljs-operator">&gt;</span><br><span class="hljs-type">Date</span>:   Sun Mar <span class="hljs-number">1</span> <span class="hljs-number">14</span>:<span class="hljs-number">40</span>:<span class="hljs-number">34</span> <span class="hljs-number">2015</span> <span class="hljs-operator">+</span><span class="hljs-number">0800</span><br><br>    removed test2.txt<br><br></code></pre></td></tr></table></figure><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline</span><br><span class="hljs-number">88</span>afe0e Merge branch <span class="hljs-string">&#x27;change_site&#x27;</span><br><span class="hljs-number">14</span>b4dca 新增加一行<br>d7e7346 changed <span class="hljs-keyword">the</span> site<br><span class="hljs-number">556</span>f0a0 removed test2.txt<br><span class="hljs-number">2e082</span>b7 <span class="hljs-built_in">add</span> test2.txt<br><span class="hljs-number">048598</span>f <span class="hljs-built_in">add</span> test.txt<br><span class="hljs-number">85</span>fc7e7 test comment <span class="hljs-built_in">from</span> w3cschool.cn<br><br></code></pre></td></tr></table></figure><p>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --oneline --graph<br><span class="hljs-comment">*   88afe0e Merge branch &#x27;change_site&#x27;</span><br>|\  <br>| * d7e7346 changed the site<br><span class="hljs-comment">* | 14b4dca 新增加一行</span><br>|/  <br><span class="hljs-comment">* 556f0a0 removed test2.txt</span><br><span class="hljs-comment">* 2e082b7 add test2.txt</span><br><span class="hljs-comment">* 048598f add test.txt</span><br><span class="hljs-comment">* 85fc7e7 test comment from w3cschool.cn</span><br><br></code></pre></td></tr></table></figure><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p><p>你也可以用 ‘–reverse’参数来逆向显示所有日志。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--reverse --oneline</span><br><span class="hljs-number">85</span>fc7e7 test comment <span class="hljs-built_in">from</span> w3cschool.cn<br><span class="hljs-number">048598</span>f <span class="hljs-built_in">add</span> test.txt<br><span class="hljs-number">2e082</span>b7 <span class="hljs-built_in">add</span> test2.txt<br><span class="hljs-number">556</span>f0a0 removed test2.txt<br>d7e7346 changed <span class="hljs-keyword">the</span> site<br><span class="hljs-number">14</span>b4dca 新增加一行<br><span class="hljs-number">88</span>afe0e Merge branch <span class="hljs-string">&#x27;change_site&#x27;</span><br><br></code></pre></td></tr></table></figure><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--author=Linus --oneline -5</span><br><span class="hljs-number">81</span>b50f3 Move <span class="hljs-string">&#x27;builtin-*&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">a</span> <span class="hljs-string">&#x27;builtin/&#x27;</span> subdirectory<br><span class="hljs-number">3</span>bb7256 make <span class="hljs-string">&quot;index-pack&quot;</span> <span class="hljs-keyword">a</span> built-<span class="hljs-keyword">in</span><br><span class="hljs-number">377</span>d027 make <span class="hljs-string">&quot;git pack-redundant&quot;</span> <span class="hljs-keyword">a</span> built-<span class="hljs-keyword">in</span><br>b532581 make <span class="hljs-string">&quot;git unpack-file&quot;</span> <span class="hljs-keyword">a</span> built-<span class="hljs-keyword">in</span><br><span class="hljs-number">112</span>dd51 make <span class="hljs-string">&quot;mktag&quot;</span> <span class="hljs-keyword">a</span> built-<span class="hljs-keyword">in</span><br><br></code></pre></td></tr></table></figure><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">log</span> <span class="hljs-comment">--oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class="hljs-number">5469e2</span>d Git <span class="hljs-number">1.7</span><span class="hljs-number">.1</span>-rc2<br>d43427d Documentation/remote-helpers: Fix typos <span class="hljs-keyword">and</span> improve <span class="hljs-keyword">language</span><br><span class="hljs-number">272</span>a36b Fixup: Second argument may be <span class="hljs-keyword">any</span> arbitrary string<br>b6c8d2d Documentation/remote-helpers: <span class="hljs-keyword">Add</span> invocation section<br><span class="hljs-number">5</span>ce4f4e Documentation/urls: Rewrite <span class="hljs-keyword">to</span> accomodate transport::address<br><span class="hljs-number">00</span>b84e9 Documentation/remote-helpers: Rewrite description<br><span class="hljs-number">03</span>aa87e Documentation: Describe other situations <span class="hljs-keyword">where</span> -z affects git diff<br><span class="hljs-number">77</span>bc694 rebase-interactive: silence <span class="hljs-built_in">warning</span> <span class="hljs-keyword">when</span> <span class="hljs-keyword">no</span> commits rewritten<br><span class="hljs-number">636</span>db2c t3301: <span class="hljs-keyword">add</span> tests <span class="hljs-keyword">to</span> use <span class="hljs-comment">--format=&quot;%N&quot;</span><br><br></code></pre></td></tr></table></figure><p>更多 git log 命令可查看：<a href="https://git-scm.com/docs/git-log">http://git-scm.com/docs/git-log</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SLURM使用教程</title>
    <link href="/2023/02/01/Slurm-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/01/Slurm-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SLURM使用教程"><a href="#SLURM使用教程" class="headerlink" title="SLURM使用教程"></a>SLURM使用教程</h1><h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><ul><li>user：用户名</li><li>node：计算节点</li><li>core：cpu核</li><li>job：作业</li><li>job step：作业步，单个作业可以有多个作业步</li><li>partition：分区，作业需在特定分区中运行</li><li>QOS：服务质量，可理解为用户可使用的CPU、内存等资源限制</li><li>tasks：任务数，默认一个任务使用一个cpu核，可理解为作业所需的cpu核数</li><li>socket：cpu插槽，可理解为物理cpu颗数</li><li>stdout：标准输出文件，程序运行正常时输出信息的文件，一般指输出到屏幕的信息</li><li>stderr：标准错误文件，程序运行出错时输出信息的文件，一般指输出到屏幕的信息</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul><li>sbatch：提交作业脚本。此脚本一般会包含一个或多个srun命令启动并行任务</li><li>sinfo：显示分区或节点状态，可以通过参数选项进行过滤、和排序</li><li>squeue：显示队列的作业及作业状态</li><li>scancel：取消排队或运行中的作业</li><li>scontrol：显示或设定slurm作业、分区、节点等状态</li><li>sacctmgr：显示和设置账户关联的QOS等信息</li><li>sacct：显示历史作业信息</li><li>srun：运行并行作业，具有多个选项，如：最大和最小节点数、处理器数、是否指定和排除节点</li></ul><h2 id="节点状态查看"><a href="#节点状态查看" class="headerlink" title="节点状态查看"></a>节点状态查看</h2><p><code>sinfo</code><br><img src="/20230201154541049/20230201035423129.png"></p><ul><li>PARRITION：节点所在分区</li><li>AVAIL：分区状态，up标识可用，down标识不可用</li><li>TIMELIMIT：程序运行最大时长，infinite表示不限制，如果限制格式为days-houres:minutes:seconds</li><li>NODES：节点数</li><li>NODELIST：节点名列表</li><li>STATE：节点状态，可能的状态包括：</li><li>allocated、alloc ：已分配</li><li>completing、comp：完成中</li><li>down：宕机</li><li>drained、drain：已失去活力</li><li>fail：失效</li><li>idle：空闲</li><li>mixed：混合，节点在运行作业，但有些空闲CPU核，可接受新作业</li><li>reserved、resv：资源预留</li><li>unknown、unk：未知原因</li></ul><p>如果状态带有后缀*，表示节点没有响应</p><h2 id="分区信息查看"><a href="#分区信息查看" class="headerlink" title="分区信息查看"></a>分区信息查看</h2><p><img src="/20230201154541049/20230201035533330.png"></p><p>DisableRootJobs:不允许root提交作业</p><p>Maxtime：最大运行时间</p><p>LLN：是否按最小负载节点调度</p><p>Maxnodes：最大节点数</p><p>Hidden：是否为隐藏分区</p><p>Default：是否为默认分区</p><p>OverSubscribe：是否允许超时</p><p>ExclusiveUser：排除的用户</p><h2 id="作业信息查看"><a href="#作业信息查看" class="headerlink" title="作业信息查看"></a>作业信息查看</h2><p><img src="/20230201154541049/20230201035616729.png"></p><ul><li>JOBID：作业号</li><li>PARITION：分区名</li><li>NAME：作业名</li><li>USER：用户名</li><li>ST：状态，常见的状态包括：</li><li>PD、Q：排队中 ，PENDING</li><li>R：运行中 ，RUNNING</li><li>CA：已取消，CANCELLED</li><li>CG：完成中，COMPLETIONG</li><li>F：已失败，FAILED</li><li>TO：超时，TIMEOUT</li><li>NF：节点失效，NODE FAILURE</li><li>CD：已完成，COMPLETED<br><img src="/20230201154541049/20230201035711947.png"></li></ul><p>批处理模式提交作业<br>1.用户编写作业脚本</p><p>2.提交作业</p><p>3.作业排队等待资源分配</p><p>4.在首节点加载执行作业脚本</p><p>5.脚本执行结束，释放资源</p><p>6.用户在输出文件中查看运行结果</p><p><img src="/20230201154541049/20230201035739038.png"></p><ul><li>作业脚本为文本文件，首行一“#!”开头，指定解释程序</li><li>脚本中可通过srun加载计算任务</li><li>一个作业可包含多个作业步</li><li>脚本在管理节点上提交，实际在计算节点上执行</li><li>脚本输出写到输出文件中</li></ul><p>以下是一些常见的作业资源需求参数，使用#SBATCH -xx xxx的方式写入脚本中即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">-J,<span class="hljs-attr">--job-name</span>：指定作业名称<br>-N,<span class="hljs-attr">--nodes</span>：节点数量<br>-n,<span class="hljs-attr">--ntasks</span>：使用的CPU核数<br><span class="hljs-attr">--mem</span>：指定每个节点上使用的物理内存<br>-t,<span class="hljs-attr">--time</span>：运行时间，超出时间限制的作业将被终止<br>-<span class="hljs-selector-tag">p</span>,<span class="hljs-attr">--partition</span>：指定分区<br><span class="hljs-attr">--reservation</span>：资源预留<br>-w,<span class="hljs-attr">--nodelist</span>：指定节点运行作业<br>-x,<span class="hljs-attr">--exclude</span>：分配给作业的节点中不要包含指定节点<br><span class="hljs-attr">--ntasks-per-node</span>：指定每个节点使用几个CPU核心<br><span class="hljs-attr">--begin</span>：指定作业开始时间<br>-D，<span class="hljs-attr">--chdir</span>：指定脚本/命令的工作目录<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Slurm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/01/hello-world/"/>
    <url>/2023/02/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
